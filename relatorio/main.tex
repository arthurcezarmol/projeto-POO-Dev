\documentclass[a4paper]{abntex2}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{multicol,multirow}
\usepackage[bottom=2.5cm,top=2.5cm,left=2.0cm,right=2.0cm]{geometry}
\usepackage{indentfirst}
\usepackage{hyperref}  %%%%
\hypersetup{colorlinks,citecolor=black,filecolor=blacke,linkcolor=blue,urlcolor=blue} %%%%
\renewcommand\thesection{\arabic{section}} % não inclui capítulo na mumeração da seção
\setcounter{page}{0} % não conta a numeração da capa
\pagestyle{myheadings} %numerar página sem títulos extras
\usepackage[abnt-emphasize=bf,alf,bibjustif,versalete]{abntex2cite}
\usepackage{lipsum} % pacote para escrever texto aleatório.

\usepackage{xcolor}
\usepackage{here}
\usepackage{hyperref}

\usepackage{tabularx}   % para tabelas ajustáveis
\usepackage{booktabs}   % para linhas mais bonitas
\usepackage{array} % Para opções de formatação de colunas / formatar colunas

\usepackage{listings}
% Configurando o estilo global do Java
\lstset{
  language=Java,
  basicstyle=\ttfamily\small,      % Fonte e tamanho do código
  keywordstyle=\color{blue},      % Cor das palavras-chave (ex: public, class, static)
  commentstyle=\color{gray},      % Cor dos comentários
  stringstyle=\color{red},        % Cor das strings (ex: "Hello, World!")
  showstringspaces=false,         % Não mostrar espaços em strings de forma especial
  numbers=left,                   % Numerar linhas à esquerda
  numberstyle=\tiny\color{gray},  % Estilo dos números de linha
  breaklines=true,                % Quebrar linhas longas automaticamente
  frame=single,                   % Adicionar uma moldura ao redor do código
  captionpos=b                    % Posição da legenda (b=bottom)
}

\begin{document}

% --- Inclusão da capa ---
\input{capa.tex}

\tableofcontents % Gera o sumário

\newpage % Garante que o sumário termine e o próximo conteúdo comece em uma nova página

\section{GitHub}

\href{https://github.com/arthurcezarmol/projeto-POO-Dev}{Clique aqui} para ser redirecionado ao repositório onde o projeto está.

\section{Descrição do sistema}

Linguagem para o back-end (e orientação a objetos) \textbf{Java} utilizando o framework \textbf{Springboot}.

Para o front-end será usado \textbf{React}.

Para o banco de dados será usado \textbf{Postgree}.

O sistema que será criado é uma plataforma interativa para o projeto PEA-Pescarte. O intuito desse sistema é criar uma plataforma onde os pescadores artesanais que participam do projeto possam logar, interagir com a plataforma e utilizar os serviços que serão fornecidos pela plataforma, como o de controle de gastos e lucro, além de informações gerais.

O sistema visa buscar fornecer serviços aos pescadores artesanais de modo a facilitar a vida deles, além de torná-los mais conectados.

As funcionalidades que estarão presentes no sistema são: 

\begin{itemize}
    \item Página \textbf{Home}: contendo as informações principais e mais relevantes do momento no site;
    \item Página \textbf{Login}: contendo a tela de login e criação de conta;
    \item Página \textbf{Serviços}: contendo serviços que podem vir a ser relevantes para os pescadores, como indicações de lojas como fábricas de gelo, lojas de artigos de pesca, informações sobre transporte, serviço de mecânico para os barcos;
    \item Página \textbf{Clima}: contendo informações sobre a previsão do tempo para o dia, se existe possibilidade de chuva, velocidade do vento, dentre outros;
    \item Página \textbf{Financeiro}: que faz um "controle" do financeiro dos pescadores, nessa página eles vão poder inserir o que pescaram e a aplicação vai fazer uma estimativa de por quanto eles deveriam vender os peixes baseado em informações estaduais e federais. Além disso, também uma opção de gerar uma planilha financeira com os gastos e lucros dos mesmos;
    \item Página \textbf{Sobre}: essa página vai conter as informações sobre o que é o projeto PEA-Pescarte.
\end{itemize}

\subsection{O que é o projeto PEA-Pescarte}

O Projeto PESCARTE tem como sua principal finalidade a criação de uma rede social regional integrada por pescadores artesanais e por seus familiares, buscando, por meio de processos educativos, promover, fortalecer e aperfeiçoar a sua organização comunitária e a sua qualificação profissional, bem como o seu envolvimento na construção participativa e na implementação de projetos de geração de trabalho e renda.

O Projeto de Educação Ambiental Pescarte (PEA Pescarte) trabalha junto às \textbf{comunidades de pesca artesanal} de Arraial do Cabo, Búzios, Cabo Frio, Campos, Carapebus, Macaé, Rio das Ostras, Quissamã, São Francisco de Itabapoana e São João da Barra. Desde 2014, atua juntamente aos pescadores artesanais e seus familiares, por meio de processos educativos, promovendo, fortalecendo e aperfeiçoando a organização comunitária e a sua qualificação profissional, bem como o seu envolvimento na construção participativa e na implementação de projetos de geração de trabalho e renda.

O processo educativo é realizado nos 10 municípios e se dá através de oficinas com temas diversos, entre eles: economia solidária, cooperativismo, políticas públicas, licenciamento ambiental, letramento digital e gestão participativa. O projeto promove, também, articulações entre os pescadores e pescadoras, com reuniões do Grupo de Trabalho, Grupo Gestor, Grupo de Acompanhamento de Obras e assembleias municipais.

\section{Requisitos funcionais e não funcionais}

\subsection{Requisitos funcionais}

Definem a \textbf{funcionalidade} que o sistema a ser desenvolvido deverá ter. Ele é um requisito relacionado com um tipo de comportamento produto de uma função do sistema.

Os requisitos funcionais deste projeto são:

\begin{itemize}
    \item Cadastrar usuários;
    \item Realizar login;
    \item Transmitir dados;
    \item Exibir informações do usuário;
    \item Mostrar serviços;
    \item Gerar documentos;
    \item Consultar documentos.
\end{itemize}

Os requisitos funcionais se relacionam diretamente a processos\footnote{processos = verbos} que o sistema deve executar. Ex: pesquisar, cadastrar, relatar, verificar, imprimir.

\subsection{Requisitos não-funcionais}

Indicam propriedades comportamentais que o sistema deve possuir.

Os requisitos não-funcionais deste sistema são:

\begin{itemize}
    \item Poder acessar a aplicação usando qualquer navegador;
    \item Poder acessar a aplicação usando qualquer dispositivo: celular, tablet ou computador (responsividade);
    \item Aplicação com informações expostas de modo que pessoas com dificuldade de usar elementos da tecnologia possa acessá-lo sem problemas (acessibilidade com botões e textos grandes e intuitivos);
    \item Boa formatação, legibilidade e confiabilidade dos documentos gerados pelo sistema;
    \item Usuários poderem fazer login somente atrelados a uma Corporativa.
\end{itemize}

\section{Diagrama de classes inicial}

\subsection{Diagrama de classes (UML)}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{imagens/UML POO DEV.png}
    \caption{Diagrama UML do projeto}
    \label{fig:uml-projeto}
\end{figure}

\subsection{Diagrama entidade relacionamento (ER)}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{imagens/Diagrama ER de banco de dados.png}
    \caption{Diagrama ER do projeto}
    \label{fig:er-projeto}
\end{figure}

\section{Fluxo básico de funcionamento}

\subsection{Diagrama de casos de uso}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{imagens/Caso de Uso POO DEV.png}
    \caption{Diagrama de Casos de Uso do projeto}
    \label{fig:casos-de-uso-projeto}
\end{figure}

\section{Orçamento}

\subsection{Custo do desenvolvimento}

Cobrando R\$100,00 a hora. Por dia seriam utilizadas pelo menos 2 horas de trabalho, considerando que seriam trabalhados 5 dias da semana no mínimo 1 hora durante 3 meses, o custo final do desenvolvimento seria por volta de R\$3000,00.

\subsection{Custo de manutenção}

Mensalmente seria cobrado o custo mensal da hospedagem do site, que seria cerca de R\$300,00. Além do custo mensal de manutenção, que seria cerca de 2 horas de trabalho por mês exclusivamente para manutenção, o que sairia cerca de R\$200,00. Resultando um total de R\$500,00 mensais.

\subsection{Custo total}

O preço total do projeto sairia pelo preço total R\$3000,00 mais R\$500,00 por mês que o cliente continuar contratando os serviços de manutenção.

\section{Cronograma detalhado por semana}

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3} % aumenta espaçamento entre linhas
\begin{tabularx}{\textwidth}{>{\bfseries}c c X}
\toprule
Semana & Datas & Atividade \\
\midrule
1  & 15/09 -- 19/09 & Planejamento do modelo do front-end \\
2  & 22/09 -- 26/09 & Criação do esqueleto do front-end \\
3  & 29/09 -- 03/10 & Planejamento e criação do banco de dados \\
4  & 06/10 -- 10/10 & Planejamento do modelo do back-end \\
5  & 13/10 -- 17/10 & Criação do back-end \\
6  & 20/10 -- 24/10 & Aprimoramento do back-end \\
7  & 27/10 -- 31/10 & Aprimoramento do back-end \\
8  & 03/11 -- 07/11 & Aprimoramento do front-end \\
9  & 10/11 -- 14/11 & Aprimoramento do front-end \\
10 & 17/11 -- 21/11 & Conexão entre front-end, back-end e banco de dados \\
11 & 24/11 -- 28/11 & Revisão geral e melhorias pontuais \\
12 & 01/12 -- 03/12 & Entrega do projeto pronto \\
\bottomrule
\end{tabularx}
\caption{Cronograma de desenvolvimento do projeto}
\end{table}

\section{Realização do projeto}

Nesta seção irei detalhar o cumprimento ou não cumprimento das tarefas propostas na seção 7.

\subsection{Primeira semana}

\textbf{Objetivo}: Planejamento do modelo front-end

\textbf{Realizado}: Foi feito um wireframe (figura \ref{fig:wireframe-projeto}) para representar uma base de como o site vai ser. Um wireframe é um esboço visual básico e de baixa fidelidade de um site ou aplicativo, que ilustra a estrutura e o layout de uma página ou tela.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{imagens/Wireframe-projeto.png}
    \caption{Wireframe do projeto}
    \label{fig:wireframe-projeto}
\end{figure}

Além disso, também foi feito o que foi proposto para a Semana 2: foram criadas as pastas iniciais do projeto (Figura \ref{fig:esqueleto-front-end}) e também foi criada uma estrutura inicial para o front-end, contendo uma NavBar funcional, que altera as páginas das seções do site corretamente e os conteúdos principais de cada página (Figura \ref{fig:estrutura-inicial-projeto}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.25\linewidth]{imagens/esqueleto-front-end.png}
    \caption{Estrutura inicial das pastas do projeto}
    \label{fig:esqueleto-front-end}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{imagens/estrutura-inicial-projeto.png}
    \caption{Estrutura inicial do site}
    \label{fig:estrutura-inicial-projeto}
\end{figure}

\subsection{Segunda semana}

\textbf{Objetivo}: Criação do esqueleto do front-end

\textbf{Realizado}: O que foi proposto na segunda semana já foi realizado na primeira. Na segunda semana nada foi feito em detrimento à semana de provas.

\subsection{Terceira semana}

\textbf{Objetivo}: Planejamento e criação do banco de dados

\textbf{Realizado}: Foi atualizado o diagrama entidade relacionamento (Figura \ref{fig:er-projeto}). Além disso foi criada a estrutura base do banco de dados, com todas as tabelas e atributos (Figura \ref{fig:estrutura-banco-de-dados}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{imagens/estrutura-banco-de-dados.png}
    \caption{Estrutura do Banco de Dados}
    \label{fig:estrutura-banco-de-dados}
\end{figure}

\subsection{Quarta semana}

\textbf{Objetivo}: Planejamento do modelo do back-end

\textbf{Realizado}: Foi definida a estrutura do back-end, como é possível ver na figura \ref{fig:estrutura-back-end}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{imagens/estrutura-back-end.png}
    \caption{Estrutura do Back-end}
    \label{fig:estrutura-back-end}
\end{figure}

Além disso também foram criadas tuplas para começar a popular as tabelas do banco de dados.

O desenvolvimento em SpringBoot segue a arquitetura MVC (Model-View-Controller). 

A camada \textbf{Model} (Modelo) é responsável por representar a lógica de negócios, os dados da aplicação e a interação com o banco de dados. 

A \textbf{Repository} serve como uma interface para abstrair a camada de acesso a dados, facilitando a interação com o banco de dados sem que a lógica de negócio tenha que se preocupar com os detalhes da persistência, ele fornece métodos para operações de CRUD (Criar, Ler, Atualizar, Excluir) e consultas, que são implementados automaticamente pelo Spring Data JPA. 

A \textbf{Service} é uma camada para implementar a lógica de negócios da aplicação, atuando como intermediário entre a camada de apresentação (Controller) e a camada de persistência (Repository). Ele encapsula as regras de negócio, coordena as operações e abstrai a complexidade do acesso ao banco de dados, promovendo uma aplicação mais modular, organizada e fácil de testar. 

E a \textbf{Controller} serve como o ponto de entrada para as requisições de uma aplicação, processando as solicitações HTTP e retornando respostas apropriadas para o cliente. Ela define os endpoints (as rotas da API), como GET, POST, PUT e DELETE, que expõem a funcionalidade do backend para o mundo exterior. Ao receber uma requisição, o controller chama a lógica de negócios na camada de serviço e, em seguida, converte os dados de entrada e saída para formatos como JSON ou XML.

\subsection{Quinta semana}

\textbf{ATRASO DEVIDO À SEMANA DE PROVAS}

\subsection{Sexta semana}

\textbf{ATRASO DEVIDO À SEMANA DE PROVAS}

\subsection{Sétima semana}

\textbf{Objetivo:} Aprimoramento do back-end

\textbf{Realizado:} 

Foi feita a criação do projeto utilizando as seguintes dependências:

\begin{itemize}
    \item Spring Web: Para criar os controladores REST (endpoints da API);
    \item Spring Security: Para cuidar da página de Login e proteger endpoints;
    \item Spring Data JPA: Para se comunicar com o banco de dados (ex: para salvar usuários);
    \item PostgreSQL Driver: Driver para poder conectar o banco PostgreSQL;
    \item Lombok: Facilita a escrita de classes (reduz boilerplate).
\end{itemize}

Foi configurada a conexão do back-end com o banco de dados, como podemos ver no código \ref{code:config-bd}

\begin{lstlisting}[caption={Conexão banco de dados com back-end}, label={code:config-bd}]
// Configuracao do PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=postgres
spring.datasource.password=190603
spring.datasource.url=jdbc:postgresql://localhost:5432/banco-pescarte
spring.jpa.generate-ddl=true

// Configuracao do Hibernate (JPA)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true

// Define o schema padrao do banco de dados para o Hibernate
spring.jpa.properties.hibernate.default_schema=pescarte
\end{lstlisting}

\section*{Criando as funcionalidades}

\subsection*{Clima}

A primeira funcionalidade adicionada foi a de Clima, visto que ela é a mais fácil de configurar pois é "externa" à aplicação, visto que ela vai buscar informações de uma API. 

A API que utilizada é a OpenWeatherMap.

Primeiro de tudo eu configurei a key da API, como podemos ver no código \ref{code:config-key-api}.

\begin{lstlisting}[caption={Configuração key da API}, label={code:config-key-api}]

// Chave do OpenWeatherMap
weather.api.key=${WEATHER_API_KEY}
// O Spring vai procurar pela variavel de ambiente chamada 'WEATHER_API_KEY' (seguranca da key)

// URL base da API
weather.api.url=https://api.openweathermap.org/data/2.5/weather

\end{lstlisting}

\textbf{OBS:} para configurar a chave eu utilizei a variável de ambiente "WEATHER\_API\_KEY", porque na hora de subir o código para o GitHub ele vai subir a variável de ambiente e não a chave (que é privada). Além disso, essa "URL base da API" é a estrutura base de consulta, quando for para uma cidade específica ela ira mudar, mas baseada nela. O formato básico da URL é: \url{https://api.openweathermap.org/data/2.5/weather?q={CIDADE}&appid={API_KEY}&lang=pt_br&units=metric}

Após configurar a chave eu criei um Service (que contém as regras de negócio/funcionalidades) e um Controller (que é onde ficam os controladores REST) para a função clima, sendo eles ClimaService e ClimaController, respectivamente.

\subsection*{Configurando o ClimaService}

Nele eu usei o RestTemplate, que vai chamar a API do OpenWeatherMap. O RestTemplate simplifica o processo de fazer requisições HTTP para API's externas. 

Criei um AppConfig para configurar o RestTemplate que vai ser um Bean, para que ele possa ser reutilizado:

\begin{lstlisting}
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
\end{lstlisting}

O código do ClimaService é:

\begin{lstlisting}
@Service
public class ClimaService {
    // Injetando o Bean "RestTemplate"
    private final RestTemplate restTemplate;

    // Pega os valores do application.properties
    @Value("${weather.api.key}")
    private String apiKey;

    @Value("${weather.api.url}")
    private String apiUrl;

    // Injecao de dependencia (via construtor)
    public ClimaService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    // Buscando o clima de uma cidade
    // Por enquanto vai ficar estatica a cidade, depois vou passar a cidade como parametro
    // OBS: DTO = Data Transfer Object
    public ClimaDTO buscarClima() {
        String cidade = "London";

        // O UriComponentsBuilder ajuda a montar a URL de forma segura
        // Aqui esta a estrutura da URL da API
        String url = UriComponentsBuilder.fromHttpUrl(apiUrl)
                .queryParam("q", cidade)
                .queryParam("appid", apiKey)
                .queryParam("units", "metric") // Para temperatura em Celsius
                .queryParam("lang", "pt_br")   // Para descricao em portugues
                .toUriString();

        try {
            // Faz a chamada GET e pede o resultado como JsonNode
            JsonNode resposta = restTemplate.getForObject(url, JsonNode.class);

            // Cria um novo objeto para clima
            ClimaDTO clima =  new ClimaDTO();

            // Navega na arvore do JSON para pegar os dados que queremos
            clima.setCidade(resposta.get("name").asText());
            clima.setPais(resposta.get("sys").get("country").asText());
            clima.setTemperatura(resposta.get("main").get("temp").asDouble());
            clima.setUmidade(resposta.get("main").get("humidity").asInt());
            clima.setPressao(resposta.get("main").get("pressure").asInt());
            clima.setDescricao(resposta.get("weather").get(0).get("description").asText());
            clima.setVelocidadeVento(resposta.get("wind").get("speed").asDouble());
            clima.setDirecaoVento(resposta.get("wind").get("deg").asDouble());
            clima.setNebulosidade(resposta.get("clouds").get("all").asInt());

            // Retorna o DTO (clima)
            return clima;

        } catch (Exception e) {     // COLOCAR MAIS TRATAMENTO DE ERROS DEPOIS
            // Tratamento de erros simples
            e.printStackTrace();
            throw new RuntimeException("Erro ao buscar dados do clima: " + e.getMessage());
        }
    }
}
\end{lstlisting}

Como podemos ver, nele eu injeto o RestTemplate e pego a chave da API e a URL base dela. Depois crio o construtor e crio um método para buscar o clima. Por hora a cidade está estática apenas para a realização de testes, e dentro do método eu uso o UriComponentsBuilder, que é uma classe pré-definida do Springboot para a construção dinâmica da URL. Depois eu faço a chamada GET e navego na árvore JSON (que é a resposta que a API me dá) e pego os valores dela e retorno para o usuário. 

Além disso também fiz um tratamento de erros simples, por enquanto.

\section*{Configurando a Segurança (SecurityConfig)}

A configuração de segurança (código \ref{code:config-seguranca}) por enquanto não está completa, ela está feita com o objetivo de permitir testes de modo mais simples. A configuração final será diferente.

Nessa classe é configurada as questões de segurança da aplicação, como a permissão de acesso à endpoints, quais requisições são permitidas e onde o front-end pode se conectar.

\begin{lstlisting}[caption={Configuração inicial de segurança}, label={code:config-seguranca}]
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // Habilita o CORS (que vai precisar para conectar com o React)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))

                // Desabilita CSRF (Cross Site Request Forgery)
                .csrf(csrf -> csrf.disable())

                // Define a politica de sessao como STATELESS (API REST nao guarda estado)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // Configura as regras de autorizacao
                .authorizeHttpRequests(authorize -> authorize
                    // Permite acesso publico ao endpoint /api/clima
                    //.requestMatchers("/api/clima/**").permitAll()

                    // Permite acesso publico ao endpoint de login
                    //.requestMatchers("/api/auth/**").permitAll()

                    // Para QUALQUER outra coisa, exige autenticacao
                    //.anyRequest().authenticated()

                        // LIBERANDO TODAS AS PERMISSOES PARA TESTAR REQUESTS (DEPOIS SERA IMPLEMENTADA A SEGURANCA)
                        .anyRequest().permitAll()
                );

    return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();

        // Porta que o React esta rodando
        corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));

        // Requisicoes que ele pode realizar
        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        corsConfiguration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        corsConfiguration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);     // aplica a todos os endpoints
        return source;
    }
}
\end{lstlisting}

\subsection*{Peixes}

A próxima funcionalidade adicionada foi a de cadastrar Peixes, para testar se as requisições estão funcionando e se a conexão com o banco de dados está correta. 

O software utilizado para realizar as requisições é o \textbf{Postman}.

Primeiro eu criei o Model para Peixes:

\begin{lstlisting}
package com.faculdade.pescarte.model;

import jakarta.persistence.*;
import lombok.Data;

@Entity
@Table(name = "peixes")
@Data
public class Peixes {
    // Atributos (colunas do banco de dados)
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_peixe")          // A coluna do banco se chama exatamente "id_peixe"
    private Long id;

    // Mapeando as colunas do banco de dados no codigo usando @Column
    @Column(name = "tipopescado")       // A coluna do banco se chama exatamente "tipopescado"
    String tipoPescado;

    @Column(name = "pesopescado")       // A coluna do banco se chama exatamente "pesopescado"
    Float pesoPescado;

    @Column(name = "valorpescado")      // A coluna do banco se chama exatamente "valorpescado"
    Float valorPescado;
}

\end{lstlisting}

Depois eu criei o Repository para Peixes:

\begin{lstlisting}
package com.faculdade.pescarte.repository;

import com.faculdade.pescarte.model.Peixes;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PeixesRepository extends JpaRepository<Peixes, Long> {
    // Spring JPA cria os metodos
}
\end{lstlisting}

\textbf{JpaRepository} é uma interface do Spring Data JPA que fornece uma maneira simplificada de interagir com bancos de dados, oferecendo métodos para operações comuns de CRUD (Create, Read, Update, Delete) sem a necessidade de escrever consultas SQL manualmente.

Depois eu criei o Service para Peixes:

\begin{lstlisting}
package com.faculdade.pescarte.service;

import com.faculdade.pescarte.model.Peixes;
import com.faculdade.pescarte.repository.PeixesRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class PeixesService {

    // Criando um repositorio
    private final PeixesRepository peixesRepository;

    // Construtor da classe
    public PeixesService(PeixesRepository peixesRepository) {
        this.peixesRepository = peixesRepository;
    }

    // Metodos
    // Metodo para mostrar todos os peixes
    public List<Peixes> listarPeixes(){
        return peixesRepository.findAll();
    }

    // OPERACOES REST

    // Metodo para buscar um peixe pelo id
    public Optional<Peixes> findById(Long id) {
        return peixesRepository.findById(id);
    }

    // Metodo para salvar/cadastrar um peixe
    public Peixes salvarPeixes(Peixes peixes) {
        return peixesRepository.save(peixes);
    }

    // Metodo para deletar/remover um peixe pelo id
    public void excluirPeixes(Long id) {
        peixesRepository.deleteById(id);
    }
}
\end{lstlisting}

E por fim criei o Controller para Peixes:

\begin{lstlisting}
package com.faculdade.pescarte.controller;

import com.faculdade.pescarte.model.Peixes;
import com.faculdade.pescarte.service.PeixesService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/peixes")
public class PeixesController {
    private final PeixesService peixesService;

    // Construtor
    public PeixesController(PeixesService peixesService) {
        this.peixesService = peixesService;
    }

    // Metodos
    // Metodo GET para ver a lista de peixes
    @GetMapping // sem endpoint. Se nao passar nada aqui ele chama o metodo por padrao quando /api/peixes for acessada
    public List<Peixes> listarPeixes() {
        return peixesService.listarPeixes();
    }

    // Metodo GET para passar o ID e me retornar o peixe
    @GetMapping("/{id}")
    public ResponseEntity<Peixes> buscarPeixesPorId(@PathVariable Long id) {
        return peixesService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // Metodo POST para inserir no banco de dados
    @PostMapping
    public Peixes salvarPeixes (@RequestBody Peixes peixes) {
        return peixesService.salvarPeixes(peixes);
    }

    // Metodo DELETE para deletar no banco de dados
    @DeleteMapping("{id}")         // deletar por id
    public ResponseEntity<Void> excluirPeixes(@PathVariable Long id) {
        peixesService.excluirPeixes(id);
        return ResponseEntity.noContent().build();
    }
}
\end{lstlisting}

Após todo esse processo o endpoint "/api/peixes" está funcionando.

\end{document}